-- automatically generated by BNF Converter
module Main where

import System.Process
import System.IO ( stdin, hGetContents, hPutStr, hPutStrLn, stderr )
import System.Environment ( getArgs, getProgName )
import System.Exit ( exitFailure, exitSuccess )
import System.FilePath (takeBaseName, takeDirectory, dropExtension)
import Control.Monad (when)

import AST.LexLatte
import AST.ParLatte
import AST.SkelLatte
import AST.PrintLatte
import AST.AbsLatte

import Frontend.TypeChecker
import qualified Frontend.AST as FAST
import Backend.Compiler

import AST.ErrM

type ParseFun a = [Token] -> Err a
type FileName    = String

myLLexer = myLexer

usage :: IO ()
usage = do
    hPutStrLn stderr $ unlines
        [ "usage: Call with one of the following argument combinations:"
        , "  --help          Display this help message."
        , "  (files)         Parse content of files verbosely."
        ]
    exitFailure

printFailure :: String -> IO ()
printFailure err = do
    hPutStrLn stderr "ERROR"
    hPutStrLn stderr err

printTypeCheckResult :: TypeCheckResult -> IO ()
printTypeCheckResult (GoodChecked _) = hPutStrLn stderr "OK"
printTypeCheckResult (BadChecked (m, err)) = case m of
        Nothing -> printFailure $ show err
        Just (line, col) -> do
            hPutStrLn stderr $ "ERROR"
            hPutStr stderr $ show line ++ ":" ++ show col ++ ": "
            hPutStrLn stderr $ show err

run :: ParseFun (Program (Maybe (Int, Int))) 
    -> String 
    -> IO (Maybe FAST.Program)
run p s = case p (myLLexer s) of
    Bad s -> printFailure s >> return Nothing
    Ok  tree -> do
        let typeChecked = typeCheck tree
        printTypeCheckResult typeChecked
        case typeChecked of
            (BadChecked _) -> return Nothing
            (GoodChecked toCompile) -> return $ Just toCompile

saveCompiled :: FileName -> String -> IO ()
saveCompiled filename compiled = do
    let asm = dropExtension filename ++ ".s"
    writeFile asm compiled
    readProcess "./compileAsm.sh" [asm] ""
    return ()

parseFile :: FileName -> IO ()
parseFile filename = do
    file <- readFile filename
    parseRes <- run pProgram file
    case parseRes of
        Nothing -> exitFailure
        Just toComp -> do
            let compiled = compile False toComp
            saveCompiled filename compiled
            exitSuccess

main :: IO ()
main = do
    args <- getArgs
    case args of
        []         -> usage
        ["--help"] -> usage
        fs         -> mapM_ parseFile fs
